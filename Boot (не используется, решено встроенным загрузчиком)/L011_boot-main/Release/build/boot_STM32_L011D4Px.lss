
./build/boot_STM32_L011D4Px.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000010  08000000  08000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000038  08000010  08000010  00008010  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text.startup 000001a8  08000048  08000048  00008048  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .consts       00000009  080001f0  080001f0  000081f0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   000008c5  00000000  00000000  000081f9  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 000002fb  00000000  00000000  00008abe  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000048  00000000  00000000  00008db9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000212  00000000  00000000  00008e01  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    000003da  00000000  00000000  00009013  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      00000070  00000000  00000000  000093ed  2**0
                  CONTENTS, READONLY
 10 .ARM.attributes 00000031  00000000  00000000  0000945d  2**0
                  CONTENTS, READONLY
 11 .debug_frame  00000074  00000000  00000000  00009490  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000033a  00000000  00000000  00009504  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000060  00000000  00000000  0000983e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000010 <Default_Handler>:
{
   main();
}

void __attribute__((naked, noreturn)) Default_Handler(){
    while(1);
 8000010:	e7fe      	b.n	8000010 <Default_Handler>

08000012 <Reset_Handler>:
    &HardFault_Handler
};

void __attribute__((naked, noreturn)) Reset_Handler()
{
   main();
 8000012:	f000 f819 	bl	8000048 <main>
 8000016:	0000      	movs	r0, r0

08000018 <SendData>:
};

static void SendData(const uint8_t* data, uint32_t size)
{
	// enable Tx
	BOOT_UART->CR1 = USART_CR1_TE | USART_CR1_UE;
 8000018:	2209      	movs	r2, #9
 800001a:	4b08      	ldr	r3, [pc, #32]	; (800003c <SendData+0x24>)
 800001c:	1841      	adds	r1, r0, r1
 800001e:	601a      	str	r2, [r3, #0]
	while (size--)
 8000020:	4288      	cmp	r0, r1
 8000022:	d006      	beq.n	8000032 <SendData+0x1a>
	{
		BOOT_UART->TDR = *(data++);		
 8000024:	7802      	ldrb	r2, [r0, #0]
 8000026:	629a      	str	r2, [r3, #40]	; 0x28
		while(!(BOOT_UART->ISR & USART_ISR_TXE_Msk));
 8000028:	69da      	ldr	r2, [r3, #28]
 800002a:	0612      	lsls	r2, r2, #24
 800002c:	d5fc      	bpl.n	8000028 <SendData+0x10>
 800002e:	3001      	adds	r0, #1
 8000030:	e7f6      	b.n	8000020 <SendData+0x8>
	}
	
	while(!(BOOT_UART->ISR & USART_ISR_TC_Msk));
 8000032:	69da      	ldr	r2, [r3, #28]
 8000034:	0652      	lsls	r2, r2, #25
 8000036:	d5fc      	bpl.n	8000032 <SendData+0x1a>
		
	//UART->CR1 = USART_CR1_UE;
}
 8000038:	4770      	bx	lr
 800003a:	46c0      	nop			; (mov r8, r8)
 800003c:	40004800 	.word	0x40004800

08000040 <errCS.4556>:
 8000040:	7f017f01                                ....

08000044 <errType.4557>:
 8000044:	7c027f01                                ...|

Disassembly of section .text.startup:

08000048 <main>:
int main(void)
{	
	
// BR = 9600 !!!!!	
	// SysTick
	SysTick->LOAD = ANSWER_WAIT_MS * SYS_CLK_FREQ_KHZ;
 8000048:	23fa      	movs	r3, #250	; 0xfa
    __set_MSP(*(__IO uint32_t*) _BOOT_FW_PAGE_START);          //устанавливаем SP приложения                                           
    Jump_To_Application();		                        //запускаем приложение	
}

int main(void)
{	
 800004a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800004c:	4c53      	ldr	r4, [pc, #332]	; (800019c <main+0x154>)
	
// BR = 9600 !!!!!	
	// SysTick
	SysTick->LOAD = ANSWER_WAIT_MS * SYS_CLK_FREQ_KHZ;
 800004e:	031b      	lsls	r3, r3, #12
    __set_MSP(*(__IO uint32_t*) _BOOT_FW_PAGE_START);          //устанавливаем SP приложения                                           
    Jump_To_Application();		                        //запускаем приложение	
}

int main(void)
{	
 8000050:	44a5      	add	sp, r4
	
// BR = 9600 !!!!!	
	// SysTick
	SysTick->LOAD = ANSWER_WAIT_MS * SYS_CLK_FREQ_KHZ;
 8000052:	4c53      	ldr	r4, [pc, #332]	; (80001a0 <main+0x158>)
	SysTick->VAL = 0;
	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
	// UART
	RCC->APB1ENR = RCC_APB1ENR_LPUART1EN | RCC_APB1ENR_USART2EN; 
 8000054:	22c0      	movs	r2, #192	; 0xc0
int main(void)
{	
	
// BR = 9600 !!!!!	
	// SysTick
	SysTick->LOAD = ANSWER_WAIT_MS * SYS_CLK_FREQ_KHZ;
 8000056:	6063      	str	r3, [r4, #4]
	SysTick->VAL = 0;
 8000058:	2300      	movs	r3, #0
	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
 800005a:	2605      	movs	r6, #5
{	
	
// BR = 9600 !!!!!	
	// SysTick
	SysTick->LOAD = ANSWER_WAIT_MS * SYS_CLK_FREQ_KHZ;
	SysTick->VAL = 0;
 800005c:	60a3      	str	r3, [r4, #8]
	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
	// UART
	RCC->APB1ENR = RCC_APB1ENR_LPUART1EN | RCC_APB1ENR_USART2EN; 
 800005e:	4b51      	ldr	r3, [pc, #324]	; (80001a4 <main+0x15c>)
 8000060:	02d2      	lsls	r2, r2, #11
	
// BR = 9600 !!!!!	
	// SysTick
	SysTick->LOAD = ANSWER_WAIT_MS * SYS_CLK_FREQ_KHZ;
	SysTick->VAL = 0;
	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
 8000062:	6026      	str	r6, [r4, #0]
	// UART
	RCC->APB1ENR = RCC_APB1ENR_LPUART1EN | RCC_APB1ENR_USART2EN; 
 8000064:	639a      	str	r2, [r3, #56]	; 0x38
	RCC->IOPENR = RCC_IOPENR_GPIOAEN;
 8000066:	2201      	movs	r2, #1
 8000068:	62da      	str	r2, [r3, #44]	; 0x2c
	BOOT_UART->CR3 = USART_CR3_HDSEL;
 800006a:	2308      	movs	r3, #8
 800006c:	4d4e      	ldr	r5, [pc, #312]	; (80001a8 <main+0x160>)
	BOOT_UART->BRR = BOOT_UART_BRR;
	// GPIO	
	BOOT_UART_PORT->OTYPER |= BOOT_GPIO_OPEN_DRAIN; // OpenDrain 1
 800006e:	2180      	movs	r1, #128	; 0x80
	SysTick->VAL = 0;
	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
	// UART
	RCC->APB1ENR = RCC_APB1ENR_LPUART1EN | RCC_APB1ENR_USART2EN; 
	RCC->IOPENR = RCC_IOPENR_GPIOAEN;
	BOOT_UART->CR3 = USART_CR3_HDSEL;
 8000070:	60ab      	str	r3, [r5, #8]
	BOOT_UART->BRR = BOOT_UART_BRR;
 8000072:	4b4e      	ldr	r3, [pc, #312]	; (80001ac <main+0x164>)
	// GPIO	
	BOOT_UART_PORT->OTYPER |= BOOT_GPIO_OPEN_DRAIN; // OpenDrain 1
	UPDATE_MASK(BOOT_UART_PORT->PUPDR, BOOT_GPIO_PULL_UP_MSK, BOOT_GPIO_PULL_UP_VAL);		//2
 8000074:	2080      	movs	r0, #128	; 0x80
	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
	// UART
	RCC->APB1ENR = RCC_APB1ENR_LPUART1EN | RCC_APB1ENR_USART2EN; 
	RCC->IOPENR = RCC_IOPENR_GPIOAEN;
	BOOT_UART->CR3 = USART_CR3_HDSEL;
	BOOT_UART->BRR = BOOT_UART_BRR;
 8000076:	60eb      	str	r3, [r5, #12]
	// GPIO	
	BOOT_UART_PORT->OTYPER |= BOOT_GPIO_OPEN_DRAIN; // OpenDrain 1
 8000078:	23a0      	movs	r3, #160	; 0xa0
 800007a:	05db      	lsls	r3, r3, #23
 800007c:	685a      	ldr	r2, [r3, #4]
 800007e:	01c9      	lsls	r1, r1, #7
 8000080:	430a      	orrs	r2, r1
 8000082:	605a      	str	r2, [r3, #4]
	UPDATE_MASK(BOOT_UART_PORT->PUPDR, BOOT_GPIO_PULL_UP_MSK, BOOT_GPIO_PULL_UP_VAL);		//2
 8000084:	68d9      	ldr	r1, [r3, #12]
 8000086:	4a4a      	ldr	r2, [pc, #296]	; (80001b0 <main+0x168>)
 8000088:	0540      	lsls	r0, r0, #21
 800008a:	4011      	ands	r1, r2
 800008c:	4301      	orrs	r1, r0
 800008e:	60d9      	str	r1, [r3, #12]
	UPDATE_MASK(BOOT_UART_PORT->AFR[BOOT_GPIO_AFR_NUM], BOOT_GPIO_AFR_MSK, BOOT_GPIO_AFR << BOOT_GPIO_AFR_POS);
 8000090:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8000092:	4948      	ldr	r1, [pc, #288]	; (80001b4 <main+0x16c>)
 8000094:	4001      	ands	r1, r0
 8000096:	20c0      	movs	r0, #192	; 0xc0
 8000098:	04c0      	lsls	r0, r0, #19
 800009a:	4301      	orrs	r1, r0
 800009c:	6259      	str	r1, [r3, #36]	; 0x24
	UPDATE_MASK(BOOT_UART_PORT->MODER, BOOT_GPIO_MODER_MSK, BOOT_GPIO_MODER_VAL);
 800009e:	6819      	ldr	r1, [r3, #0]
	
	//
	uint32_t buff32[(1<<_BOOT_PAGE_SIZE_POW) + 5]; // потому-что памяти завались....
	uint8_t *buff = (uint8_t *)buff32;
	
	SendData((const void *)&vers, sizeof(vers));
 80000a0:	4845      	ldr	r0, [pc, #276]	; (80001b8 <main+0x170>)
	BOOT_UART->BRR = BOOT_UART_BRR;
	// GPIO	
	BOOT_UART_PORT->OTYPER |= BOOT_GPIO_OPEN_DRAIN; // OpenDrain 1
	UPDATE_MASK(BOOT_UART_PORT->PUPDR, BOOT_GPIO_PULL_UP_MSK, BOOT_GPIO_PULL_UP_VAL);		//2
	UPDATE_MASK(BOOT_UART_PORT->AFR[BOOT_GPIO_AFR_NUM], BOOT_GPIO_AFR_MSK, BOOT_GPIO_AFR << BOOT_GPIO_AFR_POS);
	UPDATE_MASK(BOOT_UART_PORT->MODER, BOOT_GPIO_MODER_MSK, BOOT_GPIO_MODER_VAL);
 80000a2:	400a      	ands	r2, r1
 80000a4:	2180      	movs	r1, #128	; 0x80
 80000a6:	0589      	lsls	r1, r1, #22
 80000a8:	430a      	orrs	r2, r1
 80000aa:	601a      	str	r2, [r3, #0]
	
	//
	uint32_t buff32[(1<<_BOOT_PAGE_SIZE_POW) + 5]; // потому-что памяти завались....
	uint8_t *buff = (uint8_t *)buff32;
	
	SendData((const void *)&vers, sizeof(vers));
 80000ac:	2109      	movs	r1, #9
 80000ae:	f7ff ffb3 	bl	8000018 <SendData>
	
	BOOT_UART->CR1 = USART_CR1_RE | USART_CR1_UE;
 80000b2:	602e      	str	r6, [r5, #0]
	
	while(!(BOOT_UART->ISR & USART_ISR_RXNE_Msk))
 80000b4:	69eb      	ldr	r3, [r5, #28]
 80000b6:	069b      	lsls	r3, r3, #26
 80000b8:	d40c      	bmi.n	80000d4 <main+0x8c>
	{
		if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)
 80000ba:	6823      	ldr	r3, [r4, #0]
 80000bc:	03db      	lsls	r3, r3, #15
 80000be:	d5f9      	bpl.n	80000b4 <main+0x6c>
    uint32_t app_jump_address;
	
    typedef void(*pFunction)(void);//объявляем пользовательский тип
    pFunction Jump_To_Application;//и создаём переменную этого типа
		
		SCB->VTOR = _BOOT_FW_PAGE_START;
 80000c0:	4b3e      	ldr	r3, [pc, #248]	; (80001bc <main+0x174>)
 80000c2:	4a3f      	ldr	r2, [pc, #252]	; (80001c0 <main+0x178>)
 80000c4:	6093      	str	r3, [r2, #8]
	
    app_jump_address = *( uint32_t*) (_BOOT_FW_PAGE_START + 4);    //извлекаем адрес перехода из вектора Reset
    Jump_To_Application = (pFunction)app_jump_address;            //приводим его к пользовательскому типу
    __set_MSP(*(__IO uint32_t*) _BOOT_FW_PAGE_START);          //устанавливаем SP приложения                                           
 80000c6:	681b      	ldr	r3, [r3, #0]
  \details Assigns the given value to the Main Stack Pointer (MSP).
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 80000c8:	f383 8808 	msr	MSP, r3
    typedef void(*pFunction)(void);//объявляем пользовательский тип
    pFunction Jump_To_Application;//и создаём переменную этого типа
		
		SCB->VTOR = _BOOT_FW_PAGE_START;
	
    app_jump_address = *( uint32_t*) (_BOOT_FW_PAGE_START + 4);    //извлекаем адрес перехода из вектора Reset
 80000cc:	4b3d      	ldr	r3, [pc, #244]	; (80001c4 <main+0x17c>)
    Jump_To_Application = (pFunction)app_jump_address;            //приводим его к пользовательскому типу
    __set_MSP(*(__IO uint32_t*) _BOOT_FW_PAGE_START);          //устанавливаем SP приложения                                           
    Jump_To_Application();		                        //запускаем приложение	
 80000ce:	681b      	ldr	r3, [r3, #0]
 80000d0:	4798      	blx	r3
 80000d2:	e7ef      	b.n	80000b4 <main+0x6c>
	{
		if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)
			Go_To_User_App();
	}
	
	FLASH->PEKEYR =  0x89ABCDEF;
 80000d4:	4c3c      	ldr	r4, [pc, #240]	; (80001c8 <main+0x180>)
 80000d6:	4b3d      	ldr	r3, [pc, #244]	; (80001cc <main+0x184>)
 80000d8:	60e3      	str	r3, [r4, #12]
	FLASH->PEKEYR =  0x02030405;
 80000da:	4b3d      	ldr	r3, [pc, #244]	; (80001d0 <main+0x188>)
 80000dc:	60e3      	str	r3, [r4, #12]
	FLASH->PRGKEYR = 0x8C9DAEBF;
 80000de:	4b3d      	ldr	r3, [pc, #244]	; (80001d4 <main+0x18c>)
 80000e0:	6123      	str	r3, [r4, #16]
	FLASH->PRGKEYR = 0x13141516;
 80000e2:	4b3d      	ldr	r3, [pc, #244]	; (80001d8 <main+0x190>)
 80000e4:	6123      	str	r3, [r4, #16]
	//UART->CR1 = USART_CR1_UE;
}

static inline uint16_t ReceiveData(uint8_t *data)
{	
	BOOT_UART->CR1 = USART_CR1_RE | USART_CR1_UE;
 80000e6:	2305      	movs	r3, #5
 80000e8:	602b      	str	r3, [r5, #0]
	while(!(BOOT_UART->ISR & USART_ISR_RXNE_Msk));
 80000ea:	69eb      	ldr	r3, [r5, #28]
 80000ec:	069b      	lsls	r3, r3, #26
 80000ee:	d5fc      	bpl.n	80000ea <main+0xa2>
	*data = BOOT_UART->RDR;
 80000f0:	4b2d      	ldr	r3, [pc, #180]	; (80001a8 <main+0x160>)
 80000f2:	a801      	add	r0, sp, #4
 80000f4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	
	uint16_t size = (*data == 0xFF) ? (1<<_BOOT_PAGE_SIZE_POW) + 2 : *data;
 80000f6:	2382      	movs	r3, #130	; 0x82

static inline uint16_t ReceiveData(uint8_t *data)
{	
	BOOT_UART->CR1 = USART_CR1_RE | USART_CR1_UE;
	while(!(BOOT_UART->ISR & USART_ISR_RXNE_Msk));
	*data = BOOT_UART->RDR;
 80000f8:	b2d2      	uxtb	r2, r2
 80000fa:	7002      	strb	r2, [r0, #0]
	
	uint16_t size = (*data == 0xFF) ? (1<<_BOOT_PAGE_SIZE_POW) + 2 : *data;
 80000fc:	2aff      	cmp	r2, #255	; 0xff
 80000fe:	d000      	beq.n	8000102 <main+0xba>
 8000100:	b293      	uxth	r3, r2
	data++;
	size += 3;	// sizeByte typeByte .. CheckSummByte
	
	for(int i=1; i<size; i++)
 8000102:	2201      	movs	r2, #1
	while(!(BOOT_UART->ISR & USART_ISR_RXNE_Msk));
	*data = BOOT_UART->RDR;
	
	uint16_t size = (*data == 0xFF) ? (1<<_BOOT_PAGE_SIZE_POW) + 2 : *data;
	data++;
	size += 3;	// sizeByte typeByte .. CheckSummByte
 8000104:	3303      	adds	r3, #3
	
	for(int i=1; i<size; i++)
 8000106:	429a      	cmp	r2, r3
 8000108:	da07      	bge.n	800011a <main+0xd2>
	{
		while(!(BOOT_UART->ISR & USART_ISR_RXNE_Msk)); 
 800010a:	69e9      	ldr	r1, [r5, #28]
 800010c:	0689      	lsls	r1, r1, #26
 800010e:	d5fc      	bpl.n	800010a <main+0xc2>
		*(data++) = BOOT_UART->RDR;
 8000110:	4925      	ldr	r1, [pc, #148]	; (80001a8 <main+0x160>)
 8000112:	6a49      	ldr	r1, [r1, #36]	; 0x24
 8000114:	5481      	strb	r1, [r0, r2]
	
	uint16_t size = (*data == 0xFF) ? (1<<_BOOT_PAGE_SIZE_POW) + 2 : *data;
	data++;
	size += 3;	// sizeByte typeByte .. CheckSummByte
	
	for(int i=1; i<size; i++)
 8000116:	3201      	adds	r2, #1
 8000118:	e7f5      	b.n	8000106 <main+0xbe>
 800011a:	2200      	movs	r2, #0
 800011c:	1c11      	adds	r1, r2, #0
	while (1)
	{
		size = ReceiveData(buff);
		xor = 0;
		for (i=0; i<size; i++)
			xor ^= buff[i];
 800011e:	5c86      	ldrb	r6, [r0, r2]
	static const uint8_t errType[] = {1, 0x7F, 2, 1^0x7F^2 };
	while (1)
	{
		size = ReceiveData(buff);
		xor = 0;
		for (i=0; i<size; i++)
 8000120:	3201      	adds	r2, #1
			xor ^= buff[i];
 8000122:	4071      	eors	r1, r6
	static const uint8_t errType[] = {1, 0x7F, 2, 1^0x7F^2 };
	while (1)
	{
		size = ReceiveData(buff);
		xor = 0;
		for (i=0; i<size; i++)
 8000124:	429a      	cmp	r2, r3
 8000126:	dbfa      	blt.n	800011e <main+0xd6>
			xor ^= buff[i];
		if (xor)
 8000128:	2900      	cmp	r1, #0
 800012a:	d001      	beq.n	8000130 <main+0xe8>
		{					
			SendData(errCS, sizeof(errCS));
 800012c:	482b      	ldr	r0, [pc, #172]	; (80001dc <main+0x194>)
 800012e:	e00f      	b.n	8000150 <main+0x108>
			continue;
		}
		
		if (buff[1] == 0x87)
 8000130:	7843      	ldrb	r3, [r0, #1]
 8000132:	2b87      	cmp	r3, #135	; 0x87
 8000134:	d108      	bne.n	8000148 <main+0x100>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8000136:	f3bf 8f4f 	dsb	sy
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800013a:	4a29      	ldr	r2, [pc, #164]	; (80001e0 <main+0x198>)
 800013c:	4b20      	ldr	r3, [pc, #128]	; (80001c0 <main+0x178>)
 800013e:	60da      	str	r2, [r3, #12]
 8000140:	f3bf 8f4f 	dsb	sy
                 SCB_AIRCR_SYSRESETREQ_Msk);
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 8000144:	46c0      	nop			; (mov r8, r8)
 8000146:	e7fd      	b.n	8000144 <main+0xfc>
			NVIC_SystemReset();
	
		if (buff[1] != 0x88)
 8000148:	2b88      	cmp	r3, #136	; 0x88
 800014a:	d003      	beq.n	8000154 <main+0x10c>
		{			
			SendData(errType, sizeof(errType));
 800014c:	4823      	ldr	r0, [pc, #140]	; (80001dc <main+0x194>)
 800014e:	3004      	adds	r0, #4
 8000150:	2104      	movs	r1, #4
 8000152:	e01f      	b.n	8000194 <main+0x14c>
	return size;
}

static void FlashWriteWord(uint32_t addr, uint32_t data, uint32_t isErase) // 0 или ERASE
{		
	FLASH->PECR = isErase;
 8000154:	2682      	movs	r6, #130	; 0x82
		{			
			SendData(errType, sizeof(errType));
			continue;
		}
	
		uint32_t addr = _BOOT_FW_PAGE_START + (((buff[2]<<8) + buff[3]) << _BOOT_PAGE_SIZE_POW);
 8000156:	7883      	ldrb	r3, [r0, #2]
 8000158:	78c2      	ldrb	r2, [r0, #3]
 800015a:	021b      	lsls	r3, r3, #8
 800015c:	189b      	adds	r3, r3, r2
 800015e:	4a17      	ldr	r2, [pc, #92]	; (80001bc <main+0x174>)
 8000160:	01db      	lsls	r3, r3, #7
 8000162:	189a      	adds	r2, r3, r2
	return size;
}

static void FlashWriteWord(uint32_t addr, uint32_t data, uint32_t isErase) // 0 или ERASE
{		
	FLASH->PECR = isErase;
 8000164:	00b6      	lsls	r6, r6, #2
 8000166:	6066      	str	r6, [r4, #4]
	*(uint32_t *)addr = data;
 8000168:	6011      	str	r1, [r2, #0]
	while ( (FLASH->SR & FLASH_SR_BSY) );
 800016a:	69a1      	ldr	r1, [r4, #24]
 800016c:	07c9      	lsls	r1, r1, #31
 800016e:	d4fc      	bmi.n	800016a <main+0x122>
 8000170:	491c      	ldr	r1, [pc, #112]	; (80001e4 <main+0x19c>)
 8000172:	185e      	adds	r6, r3, r1
 8000174:	4f1c      	ldr	r7, [pc, #112]	; (80001e8 <main+0x1a0>)
 8000176:	1ad1      	subs	r1, r2, r3
 8000178:	19c9      	adds	r1, r1, r7
	return size;
}

static void FlashWriteWord(uint32_t addr, uint32_t data, uint32_t isErase) // 0 или ERASE
{		
	FLASH->PECR = isErase;
 800017a:	2700      	movs	r7, #0
		uint32_t addr = _BOOT_FW_PAGE_START + (((buff[2]<<8) + buff[3]) << _BOOT_PAGE_SIZE_POW);
		FlashWriteWord(addr, 0, ERASE);
		uint32_t word;
		for(i=0; i < (1<<_BOOT_PAGE_SIZE_POW); i+=4)
		{			
			word = /*__REV*/(*(uint32_t*)&buff[4+i]);
 800017c:	5841      	ldr	r1, [r0, r1]
	return size;
}

static void FlashWriteWord(uint32_t addr, uint32_t data, uint32_t isErase) // 0 или ERASE
{		
	FLASH->PECR = isErase;
 800017e:	6067      	str	r7, [r4, #4]
	*(uint32_t *)addr = data;
 8000180:	6011      	str	r1, [r2, #0]
	while ( (FLASH->SR & FLASH_SR_BSY) );
 8000182:	69a1      	ldr	r1, [r4, #24]
 8000184:	07c9      	lsls	r1, r1, #31
 8000186:	d4fc      	bmi.n	8000182 <main+0x13a>
		uint32_t word;
		for(i=0; i < (1<<_BOOT_PAGE_SIZE_POW); i+=4)
		{			
			word = /*__REV*/(*(uint32_t*)&buff[4+i]);
			FlashWriteWord(addr, word, 0);
			addr += 4;
 8000188:	3204      	adds	r2, #4
		}
	
		uint32_t addr = _BOOT_FW_PAGE_START + (((buff[2]<<8) + buff[3]) << _BOOT_PAGE_SIZE_POW);
		FlashWriteWord(addr, 0, ERASE);
		uint32_t word;
		for(i=0; i < (1<<_BOOT_PAGE_SIZE_POW); i+=4)
 800018a:	42b2      	cmp	r2, r6
 800018c:	d1f2      	bne.n	8000174 <main+0x12c>
			word = /*__REV*/(*(uint32_t*)&buff[4+i]);
			FlashWriteWord(addr, word, 0);
			addr += 4;
		}	
		*(uint32_t*)buff = (0x01 << 0) + (0x08 << 8) + ((0x01^0x08)<<16);// 0x01 0x08, 0x08, 0xXX			
		SendData(buff, 3);
 800018e:	2103      	movs	r1, #3
		{			
			word = /*__REV*/(*(uint32_t*)&buff[4+i]);
			FlashWriteWord(addr, word, 0);
			addr += 4;
		}	
		*(uint32_t*)buff = (0x01 << 0) + (0x08 << 8) + ((0x01^0x08)<<16);// 0x01 0x08, 0x08, 0xXX			
 8000190:	4b16      	ldr	r3, [pc, #88]	; (80001ec <main+0x1a4>)
 8000192:	9301      	str	r3, [sp, #4]
		SendData(buff, 3);
 8000194:	f7ff ff40 	bl	8000018 <SendData>
 8000198:	e7a5      	b.n	80000e6 <main+0x9e>
 800019a:	46c0      	nop			; (mov r8, r8)
 800019c:	fffffde4 	.word	0xfffffde4
 80001a0:	e000e010 	.word	0xe000e010
 80001a4:	40021000 	.word	0x40021000
 80001a8:	40004800 	.word	0x40004800
 80001ac:	0000d055 	.word	0x0000d055
 80001b0:	cfffffff 	.word	0xcfffffff
 80001b4:	f0ffffff 	.word	0xf0ffffff
 80001b8:	080001f0 	.word	0x080001f0
 80001bc:	08000200 	.word	0x08000200
 80001c0:	e000ed00 	.word	0xe000ed00
 80001c4:	08000204 	.word	0x08000204
 80001c8:	40022000 	.word	0x40022000
 80001cc:	89abcdef 	.word	0x89abcdef
 80001d0:	02030405 	.word	0x02030405
 80001d4:	8c9daebf 	.word	0x8c9daebf
 80001d8:	13141516 	.word	0x13141516
 80001dc:	08000040 	.word	0x08000040
 80001e0:	05fa0004 	.word	0x05fa0004
 80001e4:	08000280 	.word	0x08000280
 80001e8:	f7fffe04 	.word	0xf7fffe04
 80001ec:	00090801 	.word	0x00090801
